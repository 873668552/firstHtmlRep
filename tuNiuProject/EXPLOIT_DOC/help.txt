A 主要使用事件介绍

    (一) 滚动条事件在 js/amdLib/base.js 文件中(代码99行)。
    包括：（1）图片懒加载->代码1行; （2）楼梯->代码99行;

    (二) 属性监听事件在 js/htmljs/model.js 文件中(代码322行)
    包括： (1)监听ajax数据请求结果->代码364行。用的Object.defineProperty，重写set方法，可以加密。
    原理是把get方法重写，返回脏数据。原子操作。

    (三) 其他事件
    包括： 
    搜索框,jsonp请求数据：js/amdLib/main.js文件中->代码138行。callback函数在js/cmdLib/sonp.js 中。
    jsonp该进点：在script标签中添加id，每次调用时都通过id找到这个标签，清空里面的内容从新加载url资源。好处减少
    节点的创建。
    js封装轮播 
    商品效果轮播 js/htmljs/detail.js 代码:(458-619行) ;
    商品展示(shops.html)轮播： js/cmdLib/public.js 代码 (102-292行) 没得说，逻辑很难想。突破点-》给每一
    相应节点添加一个普通属性做标记。
    放大镜: js/htmljs/detail.js 代码(624-774行) 继承的思想：写了一个接口。
    手风琴 js/htmljs/model.js 代码(13-40行)
    动态加载：js/htmljs/total.js 代码(24-133行) 根据后台json文件的特点动态加载资源（主页面全都是css，其他内容部分都是动态加载）
    js特定模块封装 代码public.js(368-543行);

B 前后端

    注册：
    1 账户和密码都保存在后台文件中（路径：PHP/reg.json)。
    2 用户注册会用ajax加代理的方式访问后台数据文件。
    流程：(1) 前端ajax->1.php -> reg.json ->1.php ->前端data。
    (2) 拿到数据 进行拆分去重。对比账户名称并给予提示。如果数据中有此账户则不能注册。
    (3) 完成注册把数据添加后台文件中，删除本地data记录。前端-> reg.php -> reg.json ->前端最新数据。
    3 动态码：用ajax请求模拟。前端url请求->reg/dt.php ->前端数据

    找回密码：同上。
    
    登录：
    1 普通登录：在本地建立一个临时的回话cookie。
    2 两周登录：在本地建立一个为16天期限的cookie。
    3 浏览详情页面的时候，没有具备登录状态的强制登录。
    逻辑：(1)每次点击登录按钮，都在本地建立相应的cookie。然后在本地找到这个cookie判断是那种登录方式。（为啥这样做，
    是为了后面的增删改页面做准备。）
    (2)在跳转页面的时候，在本地取出来localStorage.getItem('flag')中的字符，判断是不是'true'是的话跳转到详情页面选购，
    反正跳转到主页面。
    (3)最后在跳转的时候找到cookie的名字显示到右上角对应的地方。

    总结：前端->php文件->json文件。有get和post基本请求；有前端加后台代理的访问。

C 感悟

    (一) 布局要明确 
    <1> 功能函数定义在一个文件中，俗称借口写在一个文件中；
    功能函数是细节处理函数，是针对特别的场景设计的，参数是一类相似的对象，设计的时候尽量考虑周全，功能可以根据参数对象设计，看看这个对象有什么拓展。

    <2> 业务逻辑的实现写在一个文件中，俗称函数的调用写在一个函数中。是业务的实现流程，主要考虑这个业务需要是什么，
    以及该调用那个接口来实现这个逻辑流程。

    <3> 总结：写项目时要明确做到某块化，切记看见一个写一个，这样不容易开发和调试，扩展性也不强。

    (二) 不能盲目写东西
    <1> 写之前要有明确的思路，好多东西写不出来是因为思路没有了。顺着思路走，一步步写肯定会出结果。

    <2> 代码书写之前要分步骤。 
    1 找到对象： 找到被加工的东西：我都要处理那个对象？怎样找到这个对象？ 
    2 对象特点化： 对象拥有什么属性? 这个对象该有什么行为？为这个事件做些什么？ 
    3 过程细分化： 到哪一步我该用什么对象，这个对象在个一段时间内干啥？下一步该有那个对象接受参数

    (三)js对象原型小结

    js 目前有两种对象，普通对象和函数对象 
    结构特点：
    函数对象比普通对象多一个属性 prototype 
    普通对象 原型__proto__ 
    函数对象 原型__proto__ ,prototype

    用处：继承和封装
    prototype,这个属性被函数对象实例化的对象所继承。都指向一个默认指向一个地方。
    如：function Person()={};
    var p = new Person();
    p.__proto__  == Person.prototype;// true
    js机制
    如果构造函数中没有添加函数，在原型中有添加，那么这个函数依然会执行。
    这样我们可以把一类相同的函数放到一个函数对象的原型中。这样可以减少代码量，方便管理。
    另外：如果堆中的对象可以被很多引用指向。如果这个空间的指向没有清空，那么这个空间会一直存在。
    单例对象就是用了这个原理。 如： function getInstance() = {
        var instance;
        if(instance == null){instance = new Person()}
        Person.prototype = instance; return instance;
        }
    函数执行完后创建了一个对象在堆中，有两个引用指向这个空间。所以每次instance 开辟的空间都有引用指向。

D git工具
名字： 分布式项目管理工具
本地work  --> 缓存区 --> 本地仓库 --> 远程仓库
本地work :git add -->缓存区:git commit --> 本地仓库:git push origin (branch) --> 远程仓库

管理：分支
1 本地：一，本地分支用于提交；二，管理本地文件（回退：gitreset --hard commit_id；查看：git log；合并：git merge。。。）
创建：git branch name; 切换：git checkout name; 删除: git branch -d name;
2 远程分支：与本地分支对应的一个分支。用处：如某个网站有1.2v，1.3v，可以建立相应的分支管理。维护和开发用的。
本地创建： 一，git branch name ;二， git push origin name;
远程仓库创建： 找到git选项，创建。不同的远程仓库有不同的操作。
3 冲突：
概念：如果你的分支在合并的时候，有文件内容和当前分支相同文件有内容冲突，那就会导致commit失败。
如：master分支有one.txt 里面有文字123。现在分支other里面也有one.txt 里面内容为abc。那么在把分支other合并到
master分支上的时候，会有冲突。

实战项目：
E 